#!/usr/bin/env python2

import os
import sys
import logging
import signal
import socket
import select

# spawned by single head daemon (rank=0)

# maintain TCP connections to all head daemons 

class ControllerDaemon:
	def __init__(self):
		self.setup_logger()

		self.log.info('starting up ControllerDaemon')

		self.shutdown = False
		self.head_daemons = {}

		self.packet_switch = {}
		self.setup_packet_switch()

		self.sockets = []
		self.setup_server_socket()

		signal.signal(signal.SIGINT, self.signal_handler)

	def __del__(self):
		self.log.info('shutting down ControllerDaemon')
		
		# close all open sockets
		for socket in self.sockets:
			socket.close()

		self.log.info('shut down complete')
		del self.log

	def signal_handler(self, signal, frame):
		self.log.warning('ControllerDaemon received signal ' + str(signal) + ' shutting down')
		self.shutdown = True

		self.__del__()
		
		sys.exit(10)

	def setup_logger(self):
		print(os.environ)
		# do logging
		if os.environ.get('EXAMPI_LOG_CONTROLLER_DAEMON', None) == 'TRUE':
			self.log = logging.getLogger('controller')
			self.log.setLevel(logging.INFO)
			
			logname = 'controller_daemon.log'
			
			handler = logging.FileHandler(logname)
			handler.setLevel(logging.INFO)

			self.log.addHandler(handler)

		# logging is disabled
		else:
			self.log = logging.getLogger(__name__)
			self.log.addHandler(logging.NullHandler())

	def setup_server_socket(self):
		self.log.info('setting up server socket')

		self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.server_socket.setblocking(0)

		self.hostname = socket.gethostname()
		self.localhost = socket.gethostbyname(self.hostname)

		self.server_socket.bind((self.localhost, int(os.environ['EXAMPI_CONTROLLER_PORT'])))
		self.server_socket.listen(5)

		self.sockets.append(self.server_socket)

	def setup_packet_switch(self):
		self.log.info('setting up packet switcher')

		self.packet_switch['node_barrier'] = self.node_barrier
		self.packet_switch['node_success'] = self.node_success
		
		self.packet_switch['process_exit'] = self.process_exit
		self.packet_switch['process_epoch'] = self.process_epoch

	def launch(self):
		self.log.info('launching ControllerDaemon')

		while not self.shutdown:
			# wait for sockets
			self.log.info('waiting for incoming')
			readables, writables, exceptionals = select.select(self.sockets, [], [])

			self.log.info('iterating readables')
			for readable in readables:
				if readable is self.server_socket:
					# handle connection request
					connection, client = readable.accept()
					connection.setblocking(0)

					self.log.info('connection accepted from ' + str(client))

					# add connection socket to tracked sockets
					self.sockets.append(connection)

				else:
					# recv on client socket
					packet = readable.recv(64).decode('utf-8').replace('\0','')
					self.log.info('packet received from ' + str(readable.getpeername()))
					self.log.info('packet: "' + str(packet) + '"')
					data = packet.split(' ')
					
					# look up and execute
					packet_handler = self.packet_switch.get(data[0], None) 
					if packet_handler:
						self.log.info('found packet handler')
						packet_handler(readable, data[1:])

					else:
						self.log.error('failed to handle: ' + str(packet))
						raise ValueError

			self.log.info('iterating writables')
			for writable in writables:
				pass

			self.log.info('iterating exceptionals')
			for exceptional in exceptionals:
				pass
		
		self.log.info('shutting down ControllerDaemon')

	def send_to_head_daemons(self, data):
		self.log.info('sending ' + str(data) + ' to all head daemons')

		for host, socket in self.head_daemons.iteritems():
			socket.send(data)
		
		self.log.info('sent to all head daemons')

	def node_barrier(self, socket, data):
		# register node barrier
		host = socket.getpeername()[0]
		self.head_daemons[host] = socket

		self.log.info('received barrier from ' + host)
		self.log.info('received ' + len(self.head_daemons) + ' node barriers')
		
		# if all nodes are present then release
		if len(self.head_daemons) == int(os.environ['EXAMPI_NODE_COUNT']):
			self.log.info('sending release')
			data = 'release\0'.ljust(64).encode('utf-8')
			
			self.send_to_head_daemons(data)
			self.log.info('sent release to all head daemons')
			
	def node_success(self, socket, data):
		raise NotImplementedError
		
		# entire node has exited with MPI_SUCCESS

		# collect all nodes

		# finally shutdown all nodes

	def process_exit(self, socket, data):
		raise NotImplementedError
		
		# decide depending on errorcode what needs to be done
		# MPI_SUCCESS nothing, doesn't need to be sent here
		# MPIX_TRY_RELOAD
		# MPI_ABORT

	def process_epoch(self, socket, data):
		raise NotImplementedError

if __name__ == '__main__':
	daemon = ControllerDaemon()
	daemon.launch()
