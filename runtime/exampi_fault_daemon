#!/usr/bin/env python2

import os
import sys
import copy
import tempfile
import subprocess
import socket
import signal
import logging

def prefix_sum(array):
	out = []

	for idx, item in enumerate(array):
		if idx == 0:
			out.append(item)
		else:
			out.append(item + out[idx-1])

	return out

def decompress_hostnames():
	nodes = os.environ['SLURM_JOB_NODELIST']
	
	command = ['scontrol']
	command.append('show')
	command.append('hostnames')
	command.append(nodes)

	process = subprocess.Popen(command, stdout=subprocess.PIPE)
	stdout, stderr = process.communicate()

	global nodelist
	nodelist = stdout.splitlines()

def lookup_setup():
	if os.environ['EXAMPI_ENV'] == 'local':
		return

	global local_global_ids
	local_global_ids = [int(gid) for gid in os.environ['SLURM_GTIDS'].split(',')]

	global local_nodename
	local_nodename = os.environ['SLURMD_NODENAME']

	# uncompress task list
	prefixes = []
	for element in os.environ['SLURM_TASKS_PER_NODE'].split(','):
		if '(' in element:
			#143(x27)
			count, mult = element.split('(x')

			for idx in xrange(int(mult[:-1])):
				prefixes.append(int(count))

		else:
			prefixes.append(int(element))

	# generate prefix sum array
	global task_count_offsets
	task_count_offsets = prefix_sum(prefixes)

	# flatten node list
	decompress_hostnames()

def lookup_rank(rank):
	if os.environ['EXAMPI_ENV'] == 'local':
		return socket.gethostname()

	else:
		# local rank
		if rank in local_global_ids:
			return socket.gethostname()

		# global rank 
		else:
			for idx, bound in enumerate(task_count_offsets):
				if rank < bound:
					return nodelist[idx]

class FaultDaemon:
	def __init__(self, daemon_port, mpi_base_port, udp_transport_base):
		self.daemon_port = daemon_port
		self.mpi_base_port = mpi_base_port
		self.udp_transport_base = udp_transport_base
		self.epoch = 0
		self.head_daemon = None
		
		self.setup_environment()

		# setup logging
		if os.environ['EXAMPI_LOG_FAULT_DAEMON'] == 'TRUE':
			self.log = logging.getLogger(__name__)
			self.log.setLevel(logging.INFO)

			logname = 'fault_daemon_' + str(self.rank) + '.log'

			handler = logging.FileHandler(logname)
			handler.setLevel(logging.INFO)

			self.log.addHandler(handler)
		
		else:
			self.log = logging.getLogger(__name__).addHandler(logging.NullHandler())

		self.setup_file_handles()
		self.write_configuration()
		self.write_epoch()

		# TODO setup signal handler

	def __del__(self):
		self.log.info('fault daemon shutting down')

		# finalize sub process
		self.process.wait()

		self.config_file.close()
		self.epoch_file.close()

		# delete config and epoch files
		os.remove(self.config_file.name)
		os.remove(self.epoch_file.name)

		# terminate head daemon
		if self.head_daemon != None:
			self.log.info('shutting down head daemon')

			self.head_daemon.terminate()
			self.head_daemon.wait()

		self.log.info('shut down complete')

	def setup_file_handles(self):
		rank = self.sub_env['EXAMPI_RANK']
		job_id = self.sub_env['EXAMPI_JOB_ID']
	
		# create temporary files
		suffix = '.' + str(self.job_id) + '.' + str(self.rank)

		self.config_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=suffix) 
		self.epoch_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=suffix)

		self.sub_env['EXAMPI_CONFIG_FILE'] = self.config_file.name
		self.sub_env['EXAMPI_EPOCH_FILE'] = self.epoch_file.name

	def setup_environment(self):
		# copy general environment
		self.sub_env = dict(copy.deepcopy(os.environ))

		# announce proper launch	
		self.sub_env['EXAMPI_MONITORED'] = 'TRUE'

		# change environment depending on scheduler
		if self.sub_env['EXAMPI_ENV'] == 'slurm':
			# application MPI rank
			self.rank = int(self.sub_env['SLURM_PROCID'])
			self.job_id = int(self.sub_env['SLURM_JOB_ID'])
			self.world_size = int(self.sub_env['SLURM_NTASKS'])

			self.sub_env['EXAMPI_RANK'] = str(self.rank)
			self.sub_env['EXAMPI_WORLD_SIZE'] = self.sub_env['SLURM_NTASKS']
			self.sub_env['EXAMPI_JOB_ID'] = str(self.sub_env['SLURM_JOB_ID'])
			self.sub_env['EXAMPI_LOCALID'] = str(self.sub_env['SLURM_LOCALID'])
			
		else: # local
			self.rank = int(self.sub_env['EXAMPI_RANK'])
			self.job_id = int(self.sub_env['EXAMPI_JOB_ID'])
			self.world_size = int(self.sub_env['EXAMPI_WORLD_SIZE'])

		# announce daemon socket port
		self.sub_env['EXAMPI_DAEMON_PORT'] = str(self.daemon_port)
		self.sub_env['EXAMPI_MPI_BASE_PORT'] = str(self.mpi_base_port)
		self.sub_env['EXAMPI_MPI_PORT'] = str(self.mpi_base_port + self.rank) 
		self.sub_env['EXAMPI_UDP_TRANSPORT_BASE'] = str(self.udp_transport_base)
		# TODO remove pid
		self.sub_env['EXAMPI_DAEMON_PID'] = str(os.getpid())
		self.sub_env['EXAMPI_EPOCH'] = str(self.epoch)

		# remove any keys with SLURM association
		# from here on we are in EXAMPI territory
		# TODO required for slurm head daemon for lookup	
		#for key in self.sub_env.keys():
		#	if 'SLURM' in key:
		#		del self.sub_env[key]
		# TODO SLURM_GTIDS needs to be passed along, or some EXAMPI form of it

	def write_epoch(self):
		# TODO could this be handled with a socket?
		self.epoch_file.write(str(self.epoch))
		self.epoch_file.close()

	def write_configuration(self):
		config = 'ppid:' + str(os.getpid()) + '\n'
		config += 'size:' + self.sub_env['EXAMPI_WORLD_SIZE'] + '\n'
		
		# static connection building
		# TODO convert to dynamic connection building through socket callback to head daemon
		for irank in xrange(self.world_size):
			hostname = lookup_rank(irank) 
			ip = socket.gethostbyname(hostname)
			config += str(irank) + ':' + ip + ':' + str(self.daemon_port) + ':' + str(self.udp_transport_base + irank) + '\n'

		self.config_file.write(config)
		self.config_file.close()

	def inform_head_daemon(self):
		# establish connection to head daemon
		sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

		sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 0)
		sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
		sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

		# bind for return message
		# TODO use tcp port, port management automatic
		sock.bind((socket.gethostname(), self.daemon_port - 1 - self.rank))

		hostname = socket.gethostname()
		host = socket.gethostbyname(hostname)

		#msg = 'termination ' + str(env['EXAMPI_RANK']) + ' ' + str(self.process.returncode)
		# todo add epoch
		#msg = msg.ljust(64)
		#msg = msg.encode('utf-8')

		#sock.sendto(msg, (host, daemon_port))
		# error check

		# todo wait for response
		#data = sock.recv(64)
		sock.close()

		# process head daemon msg
		#if msg == restart:
		#	self.launch()

		#else:
		#	# no restart
		#	pass
		
		return self.process.returncode

	def launch_head_daemon(self):
		# launch head daemon if capable and not already launched
		if (int(self.sub_env['EXAMPI_LOCALID']) == 0) and (self.head_daemon == None):
			self.log.info('fault daemon ' + self.sub_env['EXAMPI_RANK'] + ' launching head daemon')

			command = ['exampi_head_daemon']
			self.head_daemon = subprocess.Popen(command, env=self.sub_env)

	def launch(self):
		# launch head daemon if required
		self.launch_head_daemon()

		# launch command
		command = sys.argv[1:]

		self.process = subprocess.Popen(command, env=self.sub_env)
		self.process.wait()

		return self.inform_head_daemon()

	def setup_signal_handler(self):
		raise NotImplementedError

	def signal_handler(self, signal, frame):
		self.process.send_signal(signal)

		if self.head_daemon != None:
			self.head_daemon.send_signal(signal)

if __name__ == '__main__':
	lookup_setup()

	# TODO read from system config
	daemon_port = 11111
		
	# TODO with tcp this will disappear, no explicit port managemented required if these were used
	mpi_base_port = 22222
	
	# todo remove udp transport port from here, should be in system config
	udp_transport_base = 33333

	# fault daemon
	daemon = FaultDaemon(daemon_port, mpi_base_port, udp_transport_base)
	errorcode = daemon.launch()	

	# return error code
	sys.exit(errorcode)
