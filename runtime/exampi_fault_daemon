#!/usr/bin/env python2
"""This script is a daemon that wraps the execution of the MPI application. It
catches a temrination and informs the node local head daemon. Depending on
global and local id this daemon also start the head and controller daemon."""

import os
import sys
import copy
import tempfile
import subprocess
import socket
#import signal
import logging
import time

#def prefix_sum(array):
#	out = []
#
#	for idx, item in enumerate(array):
#		if idx == 0:
#			out.append(item)
#		else:
#			out.append(item + out[idx-1])
#
#	return out
#
#def decompress_hostnames():
#	nodes = os.environ['SLURM_JOB_NODELIST']
#
#	command = ['scontrol']
#	command.append('show')
#	command.append('hostnames')
#	command.append(nodes)
#
#	process = subprocess.Popen(command, stdout=subprocess.PIPE)
#	stdout, stderr = process.communicate()
#
#	global nodelist
#	nodelist = stdout.splitlines()
#
#def lookup_setup():
#	if os.environ['EXAMPI_ENV'] == 'local':
#		return
#
#	global local_global_ids
#	local_global_ids = [int(gid) for gid in os.environ['SLURM_GTIDS'].split(',')]
#
#	global local_nodename
#	local_nodename = os.environ['SLURMD_NODENAME']
#
#	# uncompress task list
#	prefixes = []
#	for element in os.environ['SLURM_TASKS_PER_NODE'].split(','):
#		if '(' in element:
#			#143(x27)
#			count, mult = element.split('(x')
#
#			for idx in xrange(int(mult[:-1])):
#				prefixes.append(int(count))
#
#		else:
#			prefixes.append(int(element))
#
#	# generate prefix sum array
#	global task_count_offsets
#	task_count_offsets = prefix_sum(prefixes)
#
#	# flatten node list
#	decompress_hostnames()
#
#def lookup_rank(rank):
#	if os.environ['EXAMPI_ENV'] == 'local':
#		return socket.gethostname()
#
#	else:
#		# local rank
#		if rank in local_global_ids:
#			return socket.gethostname()
#
#		# global rank
#		else:
#			for idx, bound in enumerate(task_count_offsets):
#				if rank < bound:
#					return nodelist[idx]

class FaultDaemon(object):
	"""FaultDaemon is the class representing the FaultDaemon wrapper around an MPI Stages enabled
	application. FaultDaemon also instantiates HeadDaemon and ControllerDaemon."""

	def __init__(self, udp_transport_base=31115):
		self.udp_transport_base = udp_transport_base

		#
		self.job_id = None
		self.world_size = None

		#
		self.epoch = None
		self.rank = None
		self.config_name = None
		self.config_file = None
		self.epoch_name = None
		self.epoch_file = None

		#
		self.sub_env = None
		self.head_daemon_instance = None
		self.head_connection = None

		#
		self.hostname = socket.gethostname()
		self.localhost = socket.gethostbyname(self.hostname)

		#
		self.setup_launch(0)
		self.setup_logger()

#		self.setup_signal_handler()

		# launch head daemon if required
		self.launch_head_daemon()

	def __del__(self):
		self.log.info('fault daemon shutting down')

		self.delete_files()

		# terminate head daemon
		if self.head_daemon_instance is not None:
			self.log.info('shutting down head daemon')

			self.head_daemon_instance.wait()

		self.log.info('shut down complete')

#	def setup_signal_handler(self):
#		"""Setup signal handler for ctrl-c, siginterupt."""
#
#		signal.signal(signal.SIGINT, self.signal_handler)
#		self.log.info('set up signal handler')
#
#	def signal_handler(self, signum, frame):
#		"""Signal handler for sigint. Terminate subprocess and clean up head daemon if required."""
#
#		self.log.info('FaultDaemon received signal ' + str(signum) + ' ' + str(frame))
#		self.process.send_signal(signum)
#
#		if self.head_daemon != None:
#			self.log.info('sending signal to head daemon')
#			self.head_daemon.send_signal(signum)
#			self.head_daemon.wait()
#
#		self.process.wait()
#
#		self.__del__()
#
#		sys.exit(12)

	def delete_files(self):
		"""Delete configuration and epoch files used for ExaMPI Stages."""

		self.config_file.close()
		self.epoch_file.close()

		# delete config and epoch files
		os.remove(self.config_file.name)
		os.remove(self.epoch_file.name)

	def setup_launch(self, epoch):
		"""Setup function for relaunch containment."""

		self.epoch = epoch

		self.setup_environment()

		self.setup_file_handles()

		self.write_configuration()

		self.write_epoch()

	def setup_logger(self):
		"""Setup FaultDaemon logger if needed."""

		# setup logging
		if os.environ.get('EXAMPI_LOG_FAULT_DAEMON', None) == 'TRUE':
			self.log = logging.getLogger(__name__)
			self.log.setLevel(logging.INFO)

			logname = 'fault_daemon_%i.log' % self.rank

			handler = logging.FileHandler(logname)
			handler.setLevel(logging.INFO)

			self.log.addHandler(handler)

		else:
			self.log = logging.getLogger(__name__)
			self.log.addHandler(logging.NullHandler())

	def setup_file_handles(self):
		"""Generate temporary files for configuration and epoch."""

		# create temporary files
		prefix = 'exampi_'
		suffix = '.' + str(self.job_id) + '.' + str(self.rank)

		self.config_file = tempfile.NamedTemporaryFile('w', suffix=suffix, prefix=prefix, delete=False)
		self.epoch_file = tempfile.NamedTemporaryFile('w', suffix=suffix, prefix=prefix, delete=False)

		self.config_name = self.config_file.name
		self.epoch_name = self.epoch_file.name

		self.sub_env['EXAMPI_CONFIG_FILE'] = self.config_file.name
		self.sub_env['EXAMPI_EPOCH_FILE'] = self.epoch_file.name

	def setup_environment(self):
		"""Setup execution environment with all required EXAMPI_* environment variables."""

		# copy general environment
		self.sub_env = dict(copy.deepcopy(os.environ))

		# announce proper launch
		self.sub_env['EXAMPI_MONITORED'] = 'TRUE'

		# change environment depending on scheduler
		if self.sub_env['EXAMPI_ENV'] == 'slurm':
			# application MPI rank
			self.rank = int(self.sub_env['SLURM_PROCID'])
			self.job_id = int(self.sub_env['SLURM_JOB_ID'])
			self.world_size = int(self.sub_env['SLURM_NTASKS'])

			self.sub_env['EXAMPI_RANK'] = str(self.rank)
			self.sub_env['EXAMPI_WORLD_SIZE'] = self.sub_env['SLURM_NTASKS']
			self.sub_env['EXAMPI_JOB_ID'] = str(self.sub_env['SLURM_JOB_ID'])
			self.sub_env['EXAMPI_LOCALID'] = str(self.sub_env['SLURM_LOCALID'])
			self.sub_env['EXAMPI_GTIDS'] = self.sub_env['SLURM_GTIDS']

		else: # local
			self.rank = int(self.sub_env['EXAMPI_RANK'])
			self.job_id = int(self.sub_env['EXAMPI_JOB_ID'])
			self.world_size = int(self.sub_env['EXAMPI_WORLD_SIZE'])

			self.sub_env['EXAMPI_GTIDS'] = ','.join(str(rank) for rank in xrange(self.world_size))

		# announce daemon socket port
		self.sub_env['EXAMPI_UDP_TRANSPORT_BASE'] = str(self.udp_transport_base)
		self.sub_env['EXAMPI_EPOCH'] = str(self.epoch)

		# remove any keys with SLURM association
		# EXAMPI territory from here
		for key in self.sub_env.keys():
			if 'SLURM' in key:
				del self.sub_env[key]

	def write_epoch(self):
		"""TODO"""

		# TODO could this be handled with a socket?
		self.epoch_file.write(str(self.epoch))
		self.epoch_file.close()

	def write_configuration(self):
		"""Write configuration file for ExaMPI Stages."""

		#config = 'ppid:%i\n' % os.getpid()
		#config = 'size:%s\n' % self.sub_env['EXAMPI_WORLD_SIZE']
		config = ''

		# static connection building
		self.establish_head_connection()

		for irank in xrange(self.world_size):
			msg = 'lookup %i' % irank
			self.head_connection.send(msg.ljust(64).encode('utf-8'))
			data = self.head_connection.recv(64)
			msg = data.decode('utf-8')

			# rank NUM HOSTNAME ADDRESS
			contents = msg.split(' ')
			address = contents[3]

			config += '%i:%s:%i\n' % (irank, address, self.udp_transport_base + irank)

		self.terminate_head_connection()

		#
		self.config_file.write(config)
		self.config_file.close()

	def establish_head_connection(self):
		"""Connect to local HeadDaemon instance."""

		self.head_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

		# (re)try connecting to head daemon
		self.log.info('attempting to connect to head daemon')
		while True:
			try:
				self.head_connection.connect((self.localhost, int(os.environ['EXAMPI_HEAD_DAEMON_PORT'])))

			except socket.error:
				self.log.info('failed to connect to head daemon, retrying...')
				time.sleep(0.1)

			else:
				self.log.info('connected to head daemon')
				break

	def terminate_head_connection(self):
		"""Close connection to local HeadDaemon instance."""

		self.head_connection.close()

	def inform_head(self, error_code):
		"""Contact local HeadDaemon and inform it of process termination. Then wait for decision
		from HeadDaemon."""

		self.log.info('informing head daemon about application termination')

		# read in last epoch from epoch file
		self.epoch_file = open(self.epoch_name, 'r')
		epoch = self.epoch_file.readline()
		self.log.info('read epoch file: %s', str(epoch))

		# send termination message
		msg = 'termination %i %i %i' % (self.rank, error_code, epoch)
		self.log.info('sending msg: %s', msg)
		data = msg.ljust(64).encode('utf-8')

		self.head_connection.send(data)
		self.log.info('informed head daemon')

		# receive response
		data = self.head_connection.recv(64)
		msg = data.decode('utf-8').replace('\0', '').strip()
		self.log.info('received: %s', msg)

		# parse packet
		contents = msg.split(' ')
		if contents[0] == 'shutdown':
			self.log.info('shutting down fault daemon, sending ack')

			data = ('shutdown_ack %i' % self.rank).ljust(64).encode('utf-8')
			self.head_connection.send(data)

			self.log.info('shut down complete')

			return False

		elif contents[0] == 'restart':
			# agreed epoch to restart from
			self.epoch = int(contents[1])

			return True

		else:
			self.log.error('unknown HeadDaemon instruction: %s', data)
			raise NotImplementedError

	def launch_head_daemon(self):
		"""Check if HeadDaemon is required to be launch from this FaultDaemon and launch it."""

		# launch head daemon if assigned
		if int(self.sub_env['EXAMPI_LOCALID']) == 0:
			self.log.info('fault daemon %s launching head daemon', self.sub_env['EXAMPI_RANK'])

			command = ['exampi_head_daemon']
			self.head_daemon_instance = subprocess.Popen(command, env=self.sub_env)

	def launch(self, command):
		"""Launch an instance of the MPI application."""

		self.log.info('launching externally %s', command)
		process = subprocess.Popen(command, env=self.sub_env)
		process.wait()

		self.log.info("application process completed")

		return process.returncode

	def execute(self):
		"""Start execution of MPI application wrapped by FaultDaemon."""

		# connect to head daemon
		self.establish_head_connection()

		# parse command from command line
		command = sys.argv[1:]

		# (re)start application until complete
		restart = True
		while restart:
			# setup launch
			self.delete_files()
			self.setup_launch(self.epoch)

			# launch external MPI application
			error_code = self.launch(command)

			# inform head daemon
			restart = self.inform_head(error_code)

		# terminate daemon connection
		self.terminate_head_connection()

def main():
	"""Launcher for FaultDaemon."""

	# fault daemon
	instance = FaultDaemon()

	#instance.set_epoch(0)

	error_code = instance.execute()

	# return error code
	sys.exit(error_code)

if __name__ == '__main__':
	main()
