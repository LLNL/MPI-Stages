#! /usr/bin/env python2

import os
import sys
import copy
import tempfile
import subprocess
import socket

def modify_environment(daemon_port, mpi_port, udp_transport_base):
	# TODO THIS ASSUMES SLURM ENVIRONMENT, MAKE COMPATIBLE WITH LOCAL
	env = dict(copy.deepcopy(os.environ))

	# announce proper launch	
	env['EXAMPI_MONITORED'] = 'TRUE'

	# announce daemon socket port on 127.0.0.1
	env['EXAMPI_DAEMON_PORT'] = str(daemon_port)
	env['EXAMPI_MPI_PORT'] = str(mpi_port)
	env['EXAMPI_UDP_TRANSPORT_BASE'] = str(udp_transport_base)

	#
	env['EXAMPI_LOCALID'] = env['SLURM_LOCALID']
	env['EXAMPI_JOB_ID'] = env['SLURM_JOB_ID']
	env['EXAMPI_PROCID'] = env['SLURM_PROCID']

	# application MPI rank
	rank = int(env['SLURM_PROCID'])
	env['EXAMPI_RANK'] = str(rank)

	# write config file
	worldsize = int(env['SLURM_NTASKS'])
	
	# TODO these both should be environment variables if needed at all
	config  = 'ppid:' + str(os.getpid()) + '\n'
	config += 'size:' + str(worldsize) + '\n'
	
	# TODO don't do this, this is static connection building
	# should at the very least be a runtime option
	# TODO this should be done through a runtime request throguh daemon sockets
	# TODO ask them which node that process lives on?
	job_id = env['SLURM_JOB_ID']
	for irank in xrange(worldsize):
		hostname = lookup_rank(irank) 
		# TODO hostname -> ip
		ip = socket.gethostbyname(hostname)
		config += str(irank) + ':' + ip + ':' + str(daemon_port) + ':' + str(udp_transport_base + irank) + '\n'

	# TODO tmp
	print(config)
	
	with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='_'+job_id+'_'+str(rank)) as config_file:
		env['EXAMPI_CONFIG_FILE'] = config_file.name
		
		config_file.write(config)		
	print('config file:', env['EXAMPI_CONFIG_FILE'])
	
	# write config variables to environment
	# TODO do we need PID?
	env['EXAMPI_DAEMON_PID'] = str(os.getpid())
	env['EXAMPI_WORLD_SIZE'] = str(worldsize)

	# application epoch
	epoch = 0
	env['EXAMPI_EPOCH'] = str(epoch)

	# write epoch file
	with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='_'+job_id+'_'+str(rank)) as epoch_file:
		env['EXAMPI_EPOCH_FILE'] = epoch_file.name
		epoch_file.write(str(epoch))

	return env

def launch_application(environment):
	# prepare stdout and stderr files
	rank = int(os.environ['EXAMPI_PROCID'])
	job_id = int(os.environ['EXAMPI_JOB_ID'])

	output_name = 'mpi.%i.%i.out' % (job_id, rank)
	error_name = 'mpi.%i.%i.err' % (job_id, rank)

	output_file = open(output_name, 'a')
	error_file = open(error_name, 'a')

	# launch application
	command = sys.argv[1:]

	print('fault_daemon launching:', command)

	process = subprocess.Popen(command, env=environment, stdout=output_file, stderr=error_file)

	process.wait()
	
	# clean up file handles
	output_file.close()
	error_file.close()

	return process.returncode

def inform_head_daemon(return_code):
	if return_code is MPI_SUCCESS:
		pass
	elif return_code is MPI_ABORT:
		pass
	elif return_code is 244:
		pass
	else:
		raise NotImplementedError
	
	# TODO send child return code to head daemon

	# potentially relaunch application
	
	# TODO finally return returncode

	return return_code

def start_head_daemon(env):
	if env['EXAMPI_LOCALID'] == 0:
		head_daemon = subprocess.Popen(command, env=os.environ)
		return head_daemon
	
if __name__ == '__main__':
	daemon_port = 13324
	udp_transport_base = 33324
	mpi_base_port = 23324
	mpi_port = mpi_base_port + int(os.environ['SLURM_PROCID'])

	# modify environment
	environment = modify_environment(daemon_port, mpi_port, udp_transport_base)

	# check if this daemon is node head daemon
	head_daemon = start_head_daemon(environment):

	# launch application process	
	returncode = launch_application(environment)

	# resolve
	returncode = inform_head_daemon(returncode)
	
	# we this fault daemon launch the head daemon
	if head_daemon is not None:
		head_daemon.wait()
	
	# propagate error code
	sys.exit(process.returncode)
