#!/usr/bin/env python2

import os
import sys
import copy
import tempfile
import subprocess
import socket
import signal
import logging

def prefix_sum(array):
	out = []

	for idx, item in enumerate(array):
		if idx == 0:
			out.append(item)
		else:
			out.append(item + out[idx-1])

	return out

def decompress_hostnames():
	nodes = os.environ['SLURM_JOB_NODELIST']
	
	command = ['scontrol']
	command.append('show')
	command.append('hostnames')
	command.append(nodes)

	process = subprocess.Popen(command, stdout=subprocess.PIPE)
	stdout, stderr = process.communicate()

	global nodelist
	nodelist = stdout.splitlines()

def lookup_setup():
	if os.environ['EXAMPI_ENV'] == 'local':
		return

	global local_global_ids
	local_global_ids = [int(gid) for gid in os.environ['SLURM_GTIDS'].split(',')]

	global local_nodename
	local_nodename = os.environ['SLURMD_NODENAME']

	# uncompress task list
	prefixes = []
	for element in os.environ['SLURM_TASKS_PER_NODE'].split(','):
		if '(' in element:
			#143(x27)
			count, mult = element.split('(x')

			for idx in xrange(int(mult[:-1])):
				prefixes.append(int(count))

		else:
			prefixes.append(int(element))

	# generate prefix sum array
	global task_count_offsets
	task_count_offsets = prefix_sum(prefixes)

	# flatten node list
	decompress_hostnames()

def lookup_rank(rank):
	if os.environ['EXAMPI_ENV'] == 'local':
		return socket.gethostname()

	else:
		# local rank
		if rank in local_global_ids:
			return socket.gethostname()

		# global rank 
		else:
			for idx, bound in enumerate(task_count_offsets):
				if rank < bound:
					return nodelist[idx]

class FaultDaemon:
	def __init__(self, daemon_port, mpi_base_port, udp_transport_base):
		self.daemon_port = daemon_port
		self.mpi_base_port = mpi_base_port
		self.udp_transport_base = udp_transport_base
		self.epoch = 0
		self.head_daemon = None

		self.setup_environment()

		logname = 'mpi_fault_daemon_' + str(self.sub_env['EXAMPI_RANK']) + '.log'
		logging.basicConfig(filename = logname, level=logging.DEBUG)
		logging.info('fault daemon initialing')

		self.setup_file_handles()
		self.write_configuration()
		self.write_epoch()

		# TODO setup signal handler

	def __del__(self):
		logging.info('fault daemon shutting down')

		# finalize sub process
		self.process.wait()

		# close sub process file handles
		self.output_file.close()
		self.error_file.close()
		self.config_file.close()
		self.epoch_file.close()

		# TODO delete config and epoch files

		# terminate head daemon
		if self.head_daemon is not None:
			logging.info('shutting down head daemon')
			self.head_daemon.terminate()
			self.head_daemon.wait()

		logging.info('shut down complete')

	def setup_file_handles(self):
		rank = self.sub_env['EXAMPI_RANK']
		job_id = self.sub_env['EXAMPI_JOB_ID']
	
		# create temporary files
		suffix = '.' + str(self.job_id) + '.' + str(self.rank)

		self.config_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=suffix) 
		self.epoch_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=suffix)

		self.sub_env['EXAMPI_CONFIG_FILE'] = self.config_file.name
		self.sub_env['EXAMPI_EPOCH_FILE'] = self.epoch_file.name

		# create full output file
		output_name = 'mpi.' + rank + '.o' + job_id
		self.output_file = open(output_name, 'a') 

		# create full error file
		error_name = 'mpi.' + rank + '.e' + job_id
		self.error_file = open(error_name, 'a') 

		# TODO do we need to close these so that the process can write to them?
	
	def setup_environment(self):
		# copy general environment
		self.sub_env = dict(copy.deepcopy(os.environ))

		# announce proper launch	
		self.sub_env['EXAMPI_MONITORED'] = 'TRUE'

		# change environment depending on scheduler
		if self.sub_env['EXAMPI_ENV'] == 'slurm':
			# application MPI rank
			self.rank = int(self.sub_env['SLURM_PROCID'])
			self.job_id = int(self.sub_env['SLURM_JOB_ID'])
			self.world_size = int(self.sub_env['SLURM_NTASKS'])

			self.sub_env['EXAMPI_RANK'] = str(self.rank)
			self.sub_env['EXAMPI_WORLD_SIZE'] = self.sub_env['SLURM_NTASKS']
			self.sub_env['EXAMPI_JOB_ID'] = str(self.sub_env['SLURM_JOB_ID'])
			self.sub_env['EXAMPI_LOCALID'] = str(self.sub_env['SLURM_LOCALID'])
			
		else: # local
			self.rank = int(self.sub_env['EXAMPI_RANK'])
			self.job_id = int(self.sub_env['EXAMPI_JOB_ID'])
			self.world_size = int(self.sub_env['EXAMPI_WORLD_SIZE'])

		# announce daemon socket port
		self.sub_env['EXAMPI_DAEMON_PORT'] = str(self.daemon_port)
		self.sub_env['EXAMPI_MPI_BASE_PORT'] = str(self.mpi_base_port)
		self.sub_env['EXAMPI_MPI_PORT'] = str(self.mpi_base_port + self.rank) 
		self.sub_env['EXAMPI_UDP_TRANSPORT_BASE'] = str(self.udp_transport_base)
		# TODO remove pid, should not be needed
		self.sub_env['EXAMPI_DAEMON_PID'] = str(os.getpid())
		self.sub_env['EXAMPI_EPOCH'] = str(self.epoch)

		# remove any keys with SLURM association
		# from here on we are in EXAMPI territory
		# TODO required for slurm head daemon for lookup	
		#for key in self.sub_env.keys():
		#	if 'SLURM' in key:
		#		del self.sub_env[key]

	def write_epoch(self):
		# TODO could this be handled with a socket?
		self.epoch_file.write(str(self.epoch))
		self.epoch_file.close()

	def write_configuration(self):
		config = 'ppid:' + str(os.getpid()) + '\n'
		config += 'size:' + self.sub_env['EXAMPI_WORLD_SIZE'] + '\n'
		
		# static connection building
		# TODO convert to dynamic connection building through socket callback to head daemon
		for irank in xrange(self.world_size):
			hostname = lookup_rank(irank) 
			ip = socket.gethostbyname(hostname)
			config += str(irank) + ':' + ip + ':' + str(self.daemon_port) + ':' + str(self.udp_transport_base + irank) + '\n'

		self.config_file.write(config)
		self.config_file.close()

	def launch_head_daemon(self):
		if int(self.sub_env['EXAMPI_LOCALID']) == 0:
			logging.info('fault daemon ' + self.sub_env['EXAMPI_RANK'] + ' launching head daemon')

			command = ['exampi_head_daemon']
			self.head_daemon = subprocess.Popen(command, env=self.sub_env)

	def inform_head_daemon(self):
		sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

		self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 0)
		self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
		self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

		hostname = socket.gethostname()
		host = socket.gethostbyname(hostname)

		# todo need to bind to port

		msg = 'termination ' + str(env['EXAMPI_RANK']) + ' ' + str(code)
		msg = msg.ljust(64)
		msg = msg.encode('utf-8')

		sock.sendto(msg, (host, daemon_port))
		
		# potentially relaunch application
		# TODO MPI STAGES
		
		sock.close()
		return code

	def launch(self):
		# launch head daemon if required
		self.launch_head_daemon()

		# launch command
		command = sys.argv[1:]
		self.process = subprocess.Popen(command, env=self.sub_env, stdout=self.output_file, stderr=self.error_file)
		self.process.wait()

		# TODO inform head daemon

	def setup_signal_handler(self):
		raise NotImplementedError

	def signal_handler(self, signal, frame):
		raise NotImplementedError
		#	process.send_signal(signal)

		#	if head_daemon is not None:
		#		head_daemon.send_signal(signal)


if __name__ == '__main__':
	lookup_setup()

	# TODO read from system config
	daemon_port = 11111
	mpi_base_port = 22222
	udp_transport_base = 33333

	# fault daemon
	daemon = FaultDaemon(daemon_port, mpi_base_port, udp_transport_base)
	daemon.launch()	

	# return error code
	sys.exit(daemon.process.returncode)
