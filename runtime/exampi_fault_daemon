#!/usr/bin/env python2

import os
import sys
import copy
import tempfile
import subprocess
import socket
import signal
import logging

def prefix_sum(array):
	out = []

	for idx, item in enumerate(array):
		if idx == 0:
			out.append(item)
		else:
			out.append(item + out[idx-1])

	return out

def decompress_hostnames():
	nodes = os.environ['SLURM_JOB_NODELIST']
	
	command = ['scontrol']
	command.append('show')
	command.append('hostnames')
	command.append(nodes)

	process = subprocess.Popen(command, stdout=subprocess.PIPE)
	stdout, stderr = process.communicate()

	global nodelist
	nodelist = stdout.splitlines()

def lookup_setup():
	if os.environ['EXAMPI_ENV'] == 'local':
		return

	global local_global_ids
	local_global_ids = [int(gid) for gid in os.environ['SLURM_GTIDS'].split(',')]

	global local_nodename
	local_nodename = os.environ['SLURMD_NODENAME']

	# uncompress task list
	prefixes = []
	for element in os.environ['SLURM_TASKS_PER_NODE'].split(','):
		if '(' in element:
			#143(x27)
			count, mult = element.split('(x')

			for idx in xrange(int(mult[:-1])):
				prefixes.append(int(count))

		else:
			prefixes.append(int(element))

	# generate prefix sum array
	global task_count_offsets
	task_count_offsets = prefix_sum(prefixes)

	# flatten node list
	decompress_hostnames()

def lookup_rank(rank):
	if os.environ['EXAMPI_ENV'] == 'local':
		return socket.gethostname()

	else:
		# local rank
		if rank in local_global_ids:
			return socket.gethostname()

		# global rank 
		else:
			for idx, bound in enumerate(task_count_offsets):
				if rank < bound:
					return nodelist[idx]

class FaultDaemon:
	def __init__(self, daemon_port, mpi_base_port, udp_transport_base, controller_port):
		self.daemon_port = daemon_port
		self.controller_port = controller_port
		self.mpi_base_port = mpi_base_port
		self.udp_transport_base = udp_transport_base
		self.epoch = 0
		self.head_daemon = None
		
		self.setup_environment()

		self.hostname = socket.gethostname()
		self.localhost = socket.gethostbyname(self.hostname)

		# setup logging
		if os.environ.get('EXAMPI_LOG_FAULT_DAEMON', None) == 'TRUE':
			self.log = logging.getLogger(__name__)
			self.log.setLevel(logging.INFO)

			logname = 'fault_daemon_' + str(self.rank) + '.log'

			handler = logging.FileHandler(logname)
			handler.setLevel(logging.INFO)

			self.log.addHandler(handler)
		
		else:
			self.log = logging.getLogger(__name__)
			self.log.addHandler(logging.NullHandler())

		self.setup_file_handles()
		self.write_configuration()
		self.write_epoch()

		self.setup_signal_handler()

	def __del__(self):
		self.log.info('fault daemon shutting down')

		# finalize sub process
		self.process.wait()

		self.config_file.close()
		self.epoch_file.close()

		# delete config and epoch files
		os.remove(self.config_file.name)
		os.remove(self.epoch_file.name)

		# terminate head daemon
		if self.head_daemon != None:
			self.log.info('shutting down head daemon')

			self.head_daemon.wait()

		self.log.info('shut down complete')
		del self.log

	def setup_file_handles(self):
		rank = self.sub_env['EXAMPI_RANK']
		job_id = self.sub_env['EXAMPI_JOB_ID']
	
		# create temporary files
		prefix = 'exampi_'
		suffix = '.' + str(self.job_id) + '.' + str(self.rank)

		self.config_file = tempfile.NamedTemporaryFile(mode='w', delete=False, prefix=prefix, suffix=suffix) 
		self.epoch_file = tempfile.NamedTemporaryFile(mode='w', delete=False, prefix=prefix, suffix=suffix)

		self.config_name = self.config_file.name
		self.epoch_name = self.epoch_file.name

		self.sub_env['EXAMPI_CONFIG_FILE'] = self.config_file.name
		self.sub_env['EXAMPI_EPOCH_FILE'] = self.epoch_file.name

	def setup_environment(self):
		# copy general environment
		self.sub_env = dict(copy.deepcopy(os.environ))

		# announce proper launch	
		self.sub_env['EXAMPI_MONITORED'] = 'TRUE'

		# change environment depending on scheduler
		if self.sub_env['EXAMPI_ENV'] == 'slurm':
			# application MPI rank
			self.rank = int(self.sub_env['SLURM_PROCID'])
			self.job_id = int(self.sub_env['SLURM_JOB_ID'])
			self.world_size = int(self.sub_env['SLURM_NTASKS'])

			self.sub_env['EXAMPI_RANK'] = str(self.rank)
			self.sub_env['EXAMPI_WORLD_SIZE'] = self.sub_env['SLURM_NTASKS']
			self.sub_env['EXAMPI_JOB_ID'] = str(self.sub_env['SLURM_JOB_ID'])
			self.sub_env['EXAMPI_LOCALID'] = str(self.sub_env['SLURM_LOCALID'])
			
		else: # local
			self.rank = int(self.sub_env['EXAMPI_RANK'])
			self.job_id = int(self.sub_env['EXAMPI_JOB_ID'])
			self.world_size = int(self.sub_env['EXAMPI_WORLD_SIZE'])

		# announce daemon socket port
		self.sub_env['EXAMPI_DAEMON_PORT'] = str(self.daemon_port)
		self.sub_env['EXAMPI_CONTROLLER_PORT'] = str(self.controller_port)
		self.sub_env['EXAMPI_MPI_BASE_PORT'] = str(self.mpi_base_port)
		self.sub_env['EXAMPI_MPI_PORT'] = str(self.mpi_base_port + self.rank) 
		self.sub_env['EXAMPI_UDP_TRANSPORT_BASE'] = str(self.udp_transport_base)
		# TODO remove pid
		self.sub_env['EXAMPI_DAEMON_PID'] = str(os.getpid())
		self.sub_env['EXAMPI_EPOCH'] = str(self.epoch)

		# remove any keys with SLURM association
		# from here on we are in EXAMPI territory
		# TODO required for slurm head daemon for lookup	
		#for key in self.sub_env.keys():
		#	if 'SLURM' in key:
		#		del self.sub_env[key]
		# TODO SLURM_GTIDS needs to be passed along, or some EXAMPI form of it

	def write_epoch(self):
		# TODO could this be handled with a socket?
		self.epoch_file.write(str(self.epoch))
		self.epoch_file.close()

	def write_configuration(self):
		config = 'ppid:' + str(os.getpid()) + '\n'
		config += 'size:' + self.sub_env['EXAMPI_WORLD_SIZE'] + '\n'
		
		# static connection building
		# TODO convert to dynamic connection building through socket callback to head daemon
		for irank in xrange(self.world_size):
			hostname = lookup_rank(irank) 
			ip = socket.gethostbyname(hostname)
			config += str(irank) + ':' + ip + ':' + str(self.daemon_port) + ':' + str(self.udp_transport_base + irank) + '\n'

		self.config_file.write(config)
		self.config_file.close()

	def inform_head_daemon(self):
		self.log.info('informing head daemon about application termination')

		# establish connection to head daemon
		head_daemon = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.log.info('created socket')

		# TODO potential for server not being up, retry
		head_daemon.connect((self.localhost, self.daemon_port))
		self.log.info('connected to head daemon')

		# read in last epoch from epoch file
		self.epoch_file = open(self.epoch_name, 'r')
		epoch = self.epoch_file.readline()
		self.log.info('read epoch file: ' + str(epoch))
	
		#
		msg = 'termination ' + str(os.environ['EXAMPI_RANK']) + ' ' + str(self.process.returncode) + ' ' + str(epoch)
		self.log.info('msg: ' + msg)
		data = msg.ljust(64).encode('utf-8')

		head_daemon.send(data)

		data = head_daemon.recv(64)
		msg = data.decode('utf-8').replace('\0', '').strip()


		if msg == 'shutdown':
			self.log.info('shutting down fault daemon, sending ack')
			
			rank = os.environ['EXAMPI_RANK']
			head_daemon.send(('shutdown_ack ' + str(rank)).ljust(64).encode('utf-8'))

			self.log.info('shut down done')
			
		else:
			self.log.error('received ' + str(data))
			raise NotImplementedError

		head_daemon.close()

		return self.process.returncode

	def launch_head_daemon(self):
		# launch head daemon if capable and not already launched
		if (int(self.sub_env['EXAMPI_LOCALID']) == 0) and (self.head_daemon == None):
			self.log.info('fault daemon ' + self.sub_env['EXAMPI_RANK'] + ' launching head daemon')

			command = ['exampi_head_daemon']
			self.head_daemon = subprocess.Popen(command, env=self.sub_env)

	def launch(self):
		# launch head daemon if required
		self.launch_head_daemon()

		# launch command
		command = sys.argv[1:]

		self.log.info('lauching ' + str(command))
		self.process = subprocess.Popen(command, env=self.sub_env)
		self.process.wait()
		
		self.log.info("application process completed")

		return self.inform_head_daemon()

	def setup_signal_handler(self):
		signal.signal(signal.SIGINT, self.signal_handler)
		self.log.info('set up signal handler')

	def signal_handler(self, signal, frame):
		self.log.info('FaultDaemon received signal ' + str(signal))
		self.process.send_signal(signal)

		if self.head_daemon != None:
			self.log.info('sending signal to head daemon')
			self.head_daemon.send_signal(signal)
			self.head_daemon.wait()

		self.process.wait()

		self.__del__()
		
		sys.exit(12)

if __name__ == '__main__':
	lookup_setup()
	
	# TODO read from system config
	daemon_port = 14117
		
	# TODO with tcp this will disappear, no explicit port managemented required if these were used
	mpi_base_port = 31127
	
	# TODO remove udp transport port from here, should be in system config
	udp_transport_base = 31111

	controller_port = 11120

	# fault daemon
	daemon = FaultDaemon(daemon_port, mpi_base_port, udp_transport_base, controller_port)
	errorcode = daemon.launch()

	# return error code
	sys.exit(errorcode)
