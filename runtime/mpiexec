#! /usr/bin/env python2

from __future__ import print_function

import sys
import os
import re
import argparse
import subprocess
import time
import signal
import copy

def run_local(arguments):
	# act as srun
	processes = []

	for rank in xrange(arguments.n):
		env = dict(copy.deepcopy(os.environ))

		env['EXAMPI_ENV'] = 'local'
		env['EXAMPI_LOCALID'] = str(rank)
		env['EXAMPI_RANK'] = str(rank)
		env['EXAMPI_JOB_ID'] = str(os.getpid())
		env['EXAMPI_WORLD_SIZE'] = str(arguments.n)

		command = ['exampi_fault_daemon']
		command.extend(arguments.program)

		print('mpiexec launching:', command)
	
		# TODO add single file output combined with STDOUT AND STDERR
		
		process = subprocess.Popen(command, env=env)
		processes.append(process)

	def wait_processes():
		for process in processes:
			process.wait()

	# create signal handler
	def signal_handler(signal, frame):
		print('MPIEXEC signal received', signal, 'forwarding to all child processes.')

		# forward signal to all processes
		for process in processes:
			process.send_signal(signal)

		# wait for processes to end
		wait_processes()

	signal.signal(signal.SIGINT, signal_handler)
	
	# without signal wait for processes
	wait_processes()

def run_slurm(arguments):
	command = ['srun']
	command.append('exampi_fault_daemon')
	command.extend(arguments.program)
	
	# declare EXAMPI_ENV
	env = dict(copy.deepcopy(os.environ))
	env['EXAMPI_ENV'] = 'slurm'

	print('srun command:', command)
		
	process = subprocess.Popen(command, env=env)
	return process.wait()

# poor mans Enum
class Scheduler:
	local = 0
	slurm = 1

def detect_scheduler():
	if os.environ.get('SLURM_JOB_ID'):
		return Scheduler.slurm

	else:
		# fallback onto local
		return Scheduler.local 
	
def parse_arguments():
	# command line argument parsing
	parser = argparse.ArgumentParser(description="ExaMPI Process Initiator")

	parser.add_argument('-n', metavar='<numprocs>', type=int, required=True)
	parser.add_argument('-d', default=False, metavar='<dirty>', type=str)
	parser.add_argument('program', metavar='<program>', type=str, nargs=argparse.REMAINDER)

	return parser.parse_args()

def execute_runtime(schedule, arguments):
	if scheduler is Scheduler.slurm:
		run_slurm(arguments)

	elif scheduler is Scheduler.local:
		run_local(arguments)
	
	else:
		raise ValueError

if __name__ == '__main__':
	# prase command line arguments
	arguments = parse_arguments()

	# detect scheduler
	scheduler = detect_scheduler()
	print('Detected scheduler:', scheduler)

	# run scheduler appropriate runtime
	execute_runtime(scheduler, arguments)
