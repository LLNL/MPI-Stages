#! /usr/bin/env python2

import sys
import os
import argparse
import subprocess
import signal
import copy
import logging

class RuntimeHandler:
	def __init__(self):
		self.detect_environment()

		#if log:
		#	logname = 'mpiexec_' + str(self.job_id) + '.log'

		#	for handler in logging.root.handlers[:]:
		#	    logging.root.removeHandler(handler)


		#logging.basicConfig(filename=logname, level=logging.ERROR)

	#	if log:
	#	
	#	else:
	#		logging.

	def detect_environment(self):
		if os.environ.get('SLURM_JOB_ID'):
			self.runtime = 'slurm'
			self.job_id = int(os.environ['SLURM_JOB_ID'])
		
		# fallback onto local
		else:
			self.runtime = 'local'
			self.job_id = int(os.getpid())

		#logging.info('detected runtime: ' + self.runtime + ' job_id ' + str(self.job_id))

	def launch(self, arguments):
		# TODO check if executable is valid, if not try local directory appending

		# NOTE could replace with dictionary
		# runtimes[self.runtime](arguments)
		if self.runtime == 'slurm':
			#logging.info('launching slurm execution')
			self.launch_slurm(arguments)

		elif self.runtime == 'local':
			#logging.info('launching local execution')
			self.launch_local(arguments)
		
		else:
			raise ValueError

	def launch_local(self, arguments):
		# act as srun
		processes = []

	 	# create appropriate output files
		if not arguments.separate_rank:
			output_name = 'local-' + str(os.getpid()) + '.out'
			output_file = open(output_name, 'a')

			# separate stdout and stderr
			if arguments.separate_error:
				error_name = 'local-' + str(os.getpid()) + '.out'
				error_file = open(error_name, 'a')

			# combined stdout and stderr
			else:
				error_file = output_file
			
		for rank in xrange(arguments.processes):
			# set individual process environment
			env = dict(copy.deepcopy(os.environ))
			env['EXAMPI_ENV'] = 'local'
			env['EXAMPI_LOCALID'] = str(rank)
			env['EXAMPI_RANK'] = str(rank)
			env['EXAMPI_JOB_ID'] = str(os.getpid())
			env['EXAMPI_WORLD_SIZE'] = str(arguments.processes)
			#logging.info('created process environment')

			# set up output file
			if arguments.separate_rank:
				output_name = 'local-' + str(os.getpid()) + '-' + str(rank) + '.out'

				output_file = open(output_name, 'a')

				if arguments.separate_error:
					error_name = 'local-' + str(os.getpid()) + '-' + str(rank) + '.err'
					error_file = open(error_name, 'a')
				
				else:
					error_file = output_file
				

			# construct command
			command = ['exampi_fault_daemon']
			command.extend(arguments.program)

			#logging.info('mpiexec launching ' + str(command))

			# TODO capture into single output file
			process = subprocess.Popen(command, env=env, stdout=output_file, stderr=error_file)
			processes.append(process)

			#logging.info('started process ' + str(process.pid))

		def wait_processes():
			for process in processes:
				process.wait()

			output_file.close()

		# create signal handler
		def signal_handler(signal, frame):
			#logging.warning('mpiexec received signal' + str(signal))

			# forward signal to all processes
			for process in processes:
				process.send_signal(signal)

			#logging.info('sent signal to all child processes.')

			# wait for processes to end
			wait_processes()

			#logging.info('waited for all child processes to die')

		signal.signal(signal.SIGINT, signal_handler)
		#logging.info('set signal handler')
		
		# without signal wait for processes
		wait_processes()
		#logging.info('waited for all child processes to die')

		self.errorcode = max(process.returncode for process in processes)
		#logging.info('local return code: ' + str(self.errorcode))

	def launch_slurm(self, arguments):
		command = ['srun']

		# check for separate error or ranks output
		if arguments.separate_error and not arguments.separate_rank:
			command.append('--output=slurm-%J.out')
			command.append('--error=slurm-%J.err')	
		
		elif arguments.separate_error and arguments.separate_rank:
			command.append('--output=slurm-%J-%t.out')
			command.append('--error=slurm-%J-%t.err')
		
		elif arguments.separate_rank and not arguments.separate_error:
			command.append('--output=slurm-%J-%t.out')

		command.append('exampi_fault_daemon')
		command.extend(arguments.program)

		# declare EXAMPI_ENV
		env = dict(copy.deepcopy(os.environ))
		env['EXAMPI_ENV'] = 'slurm'

		#logging.info('srun command:' + str(command))
			
		# launch srun process
		process = subprocess.Popen(command, env=env)
		process.wait()

		self.errorcode = process.returncode
		#logging.info('srun return code: ' + str(self.errorcode))

def parse_arguments():
	# command line argument parsing
	parser = argparse.ArgumentParser(description="ExaMPI Process Initiator")

	# number of processes
	parser.add_argument('-n', '--processes', type=int)

	# application to execute
	parser.add_argument('program', metavar='<program>', type=str, nargs=argparse.REMAINDER)
	
	# to leave all epoch and config files
	#parser.add_argument('-d', '--dirty', default=False, type=str)
	
	# separate stdout and stderr
	parser.add_argument('--separate_error', action='store_true')
	parser.add_argument('--separate_rank', action='store_true')

	# create mpiexec log
	parser.add_argument('--logexec', action='store_true')

	# create fault daemon logs
	parser.add_argument('--logfault', action='store_true')
	
	# create head daemon logs	
	parser.add_argument('--loghead', action='store_true')

	return parser.parse_args()

if __name__ == '__main__':
	# parse command line arguments
	arguments = parse_arguments()

	handler = RuntimeHandler()
	handler.launch(arguments)
	
	sys.exit(handler.errorcode)
