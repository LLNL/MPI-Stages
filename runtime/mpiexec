#! /usr/bin/env python2

import sys, os, re, argparse, subprocess, time, signal, socket, enum

schedulers = ['local', 'slurm', 'osg', 'sge']

MPI_SUCCESS = 0

def local_cleanup():
	for path in os.listdir('.'):
		if path[-3:] == "tmp":
			os.remove(path)

def run_local(arguments):
	numproc = arguments.n
	program = arguments.program

	# TODO check if executable exists
	
	local_cleanup()

	# start numproc processes of program

	# open socket on loopback network as server
	udp_ip = "127.0.0.1"
	udp_port = 50000

	udp_daemon_port = 40000
	udp_comm = 20000

	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.bind((udp_ip, udp_port))
	sock.setblocking(0)

	# generate config string
	configstr = 'ppid:' + str(os.getpid()) + '\n'
	configstr += 'size:' + str(numproc) + '\n'
	
	for rank in xrange(numproc):
		# all processes are local
		configstr += str(rank) + ':' + '127.0.0.1:' + str(udp_daemon_port + rank) + ':' + str(udp_comm + rank) + '\n'

	print('Configfile contents:')
	print(configstr)

	# launch children
	processes = {}
	outputs = {}
	for rank in xrange(numproc):
		# seperate binary
		child = [program[0], 'exampilauncher']

		# setup config
		configname = 'mpi.%i.config.tmp' % rank
		with open(configname, 'w') as configfile:
			configfile.write(configstr)

		child.append(configname)
		child.append(str(rank))
		# TODO use global config file

		# setup epoch
		epochname = 'mpi.%i.epoch.tmp' % rank
		epoch = 0

		child.append(epochname)
		child.append(str(epoch))

		with open(epochname, 'w') as epochfile:
			epochfile.write(str(epoch))

		# append user arguments
		child.extend(program[1:])

		print(child)

		# TODO pass environment?
		
		# create file handles
		outname = 'mpi.%i.%i.out' % (os.getpid(), rank)
		errname = 'mpi.%i.%i.err' % (os.getpid(), rank)
		ohandle = open(outname, 'w')
		ehandle = open(errname, 'w')
		outputs[rank] = (ohandle, ehandle)

		process = subprocess.Popen(child, stdout=ohandle, stderr=ehandle)
		processes[rank] = process

	# monitor processes
	processes_barrier = 0
	processes_running = len(processes)
	while processes_running > 0:
		# wait time between checks
		time.sleep(0.1)

		# check socket
		msg = None
		try:
			data = sock.recv(64)

			msg, rank, pid = data.split()

		except:
			pass

		# process global barrier
		if msg == 'barrier':
			processes_barrier += 1

			# is barrier complete?
			if processes_barrier == len(processes):
				for rank in xrange(numproc):
					msg = 'release\0';
					msg = msg.encode('utf-8')
					sock.sendto(msg, (udp_ip, 40000+rank))
		
		# check process alive
		for rank, process in processes.iteritems():
			# check if process is dead
			if process.poll() is not None:
				if process.returncode is MPI_SUCCESS:
					# MPI exited cleanly
					processes_running -= 1

				elif process.returncode is 255:
					# MPI abort called
					pass
				#elif
					# another option? 
	
	# clean up config & epoch files
	sock.close()
	
	for rank in xrange(numproc):
		(ohandle, ehandle) = outputs[rank]

		ohandle.close()
		ehandle.close()

	if not arguments.d:
		local_cleanup();

def run_slurm():
	
	
	
def run_sge():
	# TODO
	print("SGE/OSG NOT IMPLEMENTED, THIS IS A STUB")
	print("WE DON'T WANT THIS, SWITCH TO SLURM")

@enum.unique
class Scheduler(enum.Enum):
	local = 0
	slurm = 1

def detect_scheduler():
	if os.environ.get('SLURM_JOB_NAME'):
		return Scheduler.slurm

	elif os.environ.get('PBS_'):
		raise Exception

	else:
		# fallback onto local
		return Scheduler.local 
	
def parse_arguments():
	# command line argument parsing
	parser = argparse.ArgumentParser(description="ExaMPI Process Initiator")

	parser.add_argument('-n', metavar='<numprocs>', type=int, required=True)
	parser.add_argument('-d', default=False, metavar='<dirty>', type=str)
	parser.add_argument('program', metavar='<program>', type=str, nargs=argparse.REMAINDER)

	return parser.parse_args()

def execute_runtime(schedule, arguments):
	# modify environment variables
	# TODO export EXAMPI_CONFIG_FILE
	# TODO export EXAMPI_RANK
	# TODO export EXAMPI_EPOCH_FILE
	# TODO export EXAMPI_EPOCH
	env = os.environ

	# execute for scheduler
	if scheduler is Scheduler.slurm:
		run_slurm(arguments, env)

	elif scheduler is Scheduler.local:
		run_local(arguments, env)
	
	else:
		raise Exception

if __name__ == '__main__':
	# prase command line arguments
	arguments = parse_arguments()

	# detect scheduler
	scheduler = detect_scheduler()

	# run scheduler appropriate runtime
	execute_runtime(scheduler, arguments)
	
	## switch between local, slurm and osg
	#if scheduler is Scheduler.local:
	#	# local scheduler ie run locally multiple processes
	#	run_local(arguments)
	#
	#elif scheduler is Scheduler.slurm:
	#	# use SLURM
	#	run_slurm(arguments)

	##elif arguments.s is scheduler[2] or arguments.s is scheduler[3]:
	##	# use SGE or OSG
	##	run_sge()
