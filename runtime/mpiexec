#! /usr/bin/env python2

import sys, os, re, argparse, subprocess, time, signal, socket

schedulers = ['local', 'slurm', 'osg', 'sge']

MPI_SUCCESS = 0

def run_local(numproc, program):
	# start numproc processes of program

	# open socket on loopback network as server
	udp_ip = "127.0.0.1"
	udp_port = 50000

	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.bind((udp_ip, udp_port))
	sock.setblocking(0)

	# generate config string
	config = 'ppid:0\n'
	config += 'size:' + str(numproc) + '\n'
	
	for rank in xrange(numproc):
		# TODO FIXME don't assume local host
		config += str(rank) + ':' + '127.0.0.1:' + str(40000 + rank) + '\n'

	print('Configfile contents:')
	print(config)

	# launch children
	processes = {}
	for rank in xrange(numproc):
		# seperate binary
		child = [program[0], 'exampilauncher']

		# insert ExaMPI arguments
		configname = 'mpi.%i.config.tmp' % rank
		child.append(configname)

		# write config file
		config = open(configname, 'w')
		config.write('ppid:0\n')
		config.write('size:'+str(numproc))
		config.close()

		# rank number
		child.append(str(rank))

		epochname = 'mpi.%i.epoch.tmp' % rank
		child.append(epochname)

		epoch = 0
		child.append(str(epoch))

		# append user arguments
		child.extend(program[1:])

		print(child)

		# TODO pass environment?
		process = subprocess.Popen(child)
		processes[rank] = process

	# monitor processes
	while len(processes) > 0:
		# check process alive
		for rank, process in processes.iteritems():
			# wait 1s between processes
			time.sleep(1)

			# check socket
			try:
				data = sock.recv(64)
				print(data, addr)
				
				rank, msg = (0, 0)

				if msg is 'barrier':
					# barrier entry
					# release with last barrier
					pass
			except:
				pass

			# check if process is dead
			if process.poll() is not None:
				if process.returncode is MPI_SUCCESS:
					# MPI exited cleanly
					del processes[idx]
				elif process.returncode is 255:
					# MPI abort called
					pass
				#elif
					# another option? 
	

def run_slurm():
	# TODO execute srun externally, plugin required
	print("SLURM NOT IMPLEMENTED, THIS IS A STUB")
	
def run_sge():
	# TODO
	print("SGE/OSG NOT IMPLEMENTED, THIS IS A STUB")
	print("WE DON'T WANT THIS, SWITCH TO SLURM")

if __name__ == '__main__':
	# command line argument parsing
	parser = argparse.ArgumentParser(description="ExaMPI Process Initiator")

	parser.add_argument('-n', metavar='<numprocs>', type=int, required=True, help='Number of processes to start (required).')

	parser.add_argument('-s', default=schedulers[0], metavar='<scheduler>', type=str, help='Job scheduler environment to use.', choices=schedulers)
	
	parser.add_argument('program', metavar='<program>', type=str, nargs=argparse.REMAINDER, help='Program binary to execute with flags.')

	# TODO add additional argument possible by standard, section 8.8
	
	arguments = parser.parse_args()
	
	# switch between local, slurm and osg
	if arguments.s is schedulers[0]:
		# local scheduler ie run locally multiple processes
		run_local(arguments.n, arguments.program)
	
	elif arguments.s is scheduler[1]:
		# use SLURM
		run_slurm()

	elif arguments.s is scheduler[2] or arguments.s is scheduler[3]:
		# use SGE or OSG
		run_sge()
