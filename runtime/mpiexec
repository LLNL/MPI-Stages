#! /usr/bin/env python2

import sys
import os
import argparse
import subprocess
import signal
import copy
import logging
import random
import socket

class RuntimeHandler:
	def __init__(self, arguments):
		self.arguments = arguments

		self.setup_logger()

		self.detect_environment()

		self.set_head_port()
		self.set_control_port()
	
	def setup_logger(self):
		if self.arguments.logexec:
			self.log = logging.getLogger(__name__)
			self.log.setLevel(logging.INFO)
			
			logname = 'mpiexec.log'

			handler = logging.FileHandler(logname)
			handler.setLevel(logging.INFO)

			self.log.addHandler(handler)
		
		else:
			self.log = logging.getLogger(__name__)
			self.log.addHandler(logging.NullHandler())

	def test_bind(self, port):
		# XXX this only tests on the root node of the allocation
		# CAN still FAIL on other nodes, the assumption is that the other nodes will
		# have identical ports used!

		sokt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		
		try:
			sokt.bind((socket.gethostname(), port))
		
		except:
			self.log.warning('failed to bind socket port ' + str(port))
			return False
		
		else:
			self.log.info('successful binding on port ' + str(port))
			return True
		
		finally:
			sokt.close()

	def set_head_port(self):
		self.log.info('setting head daemon port')

		# argument provided port
		if self.arguments.headport != None:
			self.head_daemon_port = self.arguments.headport

			if not self.test_bind(self.head_daemon_port):
				self.log.error('prescribed head port is not able to be bound!')
				raise OSError

		# random port needed
		else:
			while True:
				self.head_daemon_port = random.randint(20001, 30000)

				if self.test_bind(self.head_daemon_port):
					break
		
		self.log.info('head daemon port set to: ' + str(self.head_daemon_port))

	def set_control_port(self):
		self.log.info('setting controller daemon port')

		# argument provided port
		if self.arguments.controlport != None:
			self.controller_daemon_port = self.arguments.controlport

			if not self.test_bind(self.controller_daemon_port):
				self.log.error('prescribed control port is not able to be bound!')
				raise OSError

		# random port needed
		else:
			while True:
				self.controller_daemon_port = random.randint(30001, 40000)

				if self.test_bind(self.controller_daemon_port):
					break
		
		self.log.info('control daemon port set to: ' + str(self.controller_daemon_port))

	def detect_environment(self):
		if os.environ.get('SLURM_JOB_ID'):
			self.runtime = 'slurm'
			self.job_id = int(os.environ['SLURM_JOB_ID'])
		
		# fallback onto local
		else:
			self.runtime = 'local'
			self.job_id = int(os.getpid())

		self.log.info('detected runtime: ' + self.runtime + ' job_id ' + str(self.job_id))

	def launch(self):
		# TODO check if executable is valid, if not try local directory appending

		# NOTE could replace with dictionary
		# runtimes[self.runtime](arguments)
		if self.runtime == 'slurm':
			self.log.info('launching slurm execution')
			self.launch_slurm(arguments)

		elif self.runtime == 'local':
			self.log.info('launching local execution')
			self.launch_local(arguments)
		
		else:
			raise ValueError

		self.log.info('finished successfully\n')

	def launch_local(self, arguments):
		# act as srun
		processes = []

	 	# create appropriate output files
		if not arguments.separate_rank:
			output_name = 'local-' + str(os.getpid()) + '.out'
			output_file = open(output_name, 'a')

			# separate stdout and stderr
			if arguments.separate_error:
				error_name = 'local-' + str(os.getpid()) + '.out'
				error_file = open(error_name, 'a')

			# combined stdout and stderr
			else:
				error_file = output_file
			
		for rank in xrange(arguments.processes):
			# set individual process environment
			env = dict(copy.deepcopy(os.environ))
			env['EXAMPI_ENV'] = 'local'

			if arguments.logfault:
				env['EXAMPI_LOG_FAULT_DAEMON'] = 'TRUE'
			if arguments.loghead:
				env['EXAMPI_LOG_HEAD_DAEMON'] = 'TRUE'
			if arguments.loghead:
				env['EXAMPI_LOG_CONTROLLER_DAEMON'] = 'TRUE'

			env['EXAMPI_LOCALID'] = str(rank)
			env['EXAMPI_RANK'] = str(rank)
			env['EXAMPI_JOB_ID'] = str(os.getpid())
			env['EXAMPI_WORLD_SIZE'] = str(arguments.processes)
			env['EXAMPI_HEAD_DAEMON_PORT'] = str(self.head_daemon_port)
			env['EXAMPI_CONTROLLER_DAEMON_PORT'] = str(self.controller_daemon_port)

			self.log.info('created process environment')

			# set up output file
			if arguments.separate_rank:
				output_name = 'local-' + str(os.getpid()) + '-' + str(rank) + '.out'

				output_file = open(output_name, 'a')

				if arguments.separate_error:
					error_name = 'local-' + str(os.getpid()) + '-' + str(rank) + '.err'
					error_file = open(error_name, 'a')
				
				else:
					error_file = output_file
				


			# construct command
			command = ['exampi_fault_daemon']
			command.extend(arguments.program)

			self.log.info('mpiexec launching ' + str(command))

			# launch process
			process = subprocess.Popen(command, env=env, stdout=output_file, stderr=error_file)
			processes.append(process)

			self.log.info('started process ' + str(process.pid))

		def wait_processes():
			for process in processes:
				process.wait()

			output_file.close()

		# create signal handler
		def signal_handler(signal, frame):
			self.log.warning('mpiexec received signal' + str(signal))

			# forward signal to all processes
			for process in processes:
				process.send_signal(signal)

			self.log.info('sent signal to all child processes.')

			# wait for processes to end
			wait_processes()

			self.log.info('waited for all child processes to die')

		signal.signal(signal.SIGINT, signal_handler)
		self.log.info('set signal handler')
		
		# without signal wait for processes
		wait_processes()
		self.log.info('waited for all child processes to die')

		self.errorcode = max(process.returncode for process in processes)
		self.log.info('local return code: ' + str(self.errorcode))

	def launch_slurm(self, arguments):
		command = ['srun']

		# check for separate error or ranks output
		if arguments.separate_error and not arguments.separate_rank:
			command.append('--output=slurm-%J.out')
			command.append('--error=slurm-%J.err')	
		
		elif arguments.separate_error and arguments.separate_rank:
			command.append('--output=slurm-%J-%t.out')
			command.append('--error=slurm-%J-%t.err')
		
		elif arguments.separate_rank and not arguments.separate_error:
			command.append('--output=slurm-%J-%t.out')

		command.append('exampi_fault_daemon')
		command.extend(arguments.program)

		# declare EXAMPI_ENV
		env = dict(copy.deepcopy(os.environ))
		env['EXAMPI_ENV'] = 'slurm'
		env['EXAMPI_HEAD_DAEMON_PORT'] = str(self.head_daemon_port)
		env['EXAMPI_CONTROLLER_DAEMON_PORT'] = str(self.controller_daemon_port)
		
		if arguments.logfault:
			env['EXAMPI_LOG_FAULT_DAEMON'] = 'TRUE'
		if arguments.loghead:
			env['EXAMPI_LOG_HEAD_DAEMON'] = 'TRUE'
		if arguments.loghead:
			env['EXAMPI_LOG_CONTROLLER_DAEMON'] = 'TRUE'

		self.log.info('srun command:' + str(command))
			
		# launch srun process
		process = subprocess.Popen(command, env=env)
		process.wait()

		self.errorcode = process.returncode
		self.log.info('srun return code: ' + str(self.errorcode))

def parse_arguments():
	# command line argument parsing
	parser = argparse.ArgumentParser(description="ExaMPI Process Initiator")

	# number of processes
	parser.add_argument('-n', '--processes', type=int)

	# application to execute
	parser.add_argument('program', metavar='<program>', type=str, nargs=argparse.REMAINDER)
	
	# to leave all epoch and config files
	#parser.add_argument('-d', '--dirty', default=False, type=str)
	
	# separate stdout and stderr
	parser.add_argument('--separate_error', action='store_true')
	parser.add_argument('--separate_rank', action='store_true')

	# create mpiexec log
	parser.add_argument('--logexec', action='store_true')

	# create fault daemon logs
	parser.add_argument('--logfault', action='store_true')
	
	# create head daemon logs	
	parser.add_argument('--loghead', action='store_true')

	# create head daemon logs	
	parser.add_argument('--logcontrol', action='store_true')

	# allow explicit head daemon port setting
	parser.add_argument('--headport', type=int, default=None)

	# allow explicit controller daemon port setting
	parser.add_argument('--controlport', type=int, default=None)

	return parser.parse_args()

if __name__ == '__main__':
	# parse command line arguments
	arguments = parse_arguments()

	handler = RuntimeHandler(arguments)
	handler.launch()
	
	sys.exit(handler.errorcode)
