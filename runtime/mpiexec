#! /usr/bin/env python2

import sys
import os
import re
import argparse
import subprocess
import time
import signal
import socket
import copy

def run_local(arguments):
	# act as srun
	processes = []

	for rank in xrange(arguments.n):
		command = ['exampi_fault_daemon']
		command.extend(arguments.program)

		env = os.environ
		env['EXAMPI_ENV'] = 'local'
		env['EXAMPI_LOCALID'] = str(rank)
		env['EXAMPI_JOB_ID'] = str(os.getpid())
		env['EXAMPI_WORLD_SIZE'] = str(arguments.n)
		
		process = subprocess.Popen(command, env=env);
		processes.append(process)

	# wait for processes
	for process in processes:
		process.wait()

def run_slurm(arguments):
	command = ['srun']
	command.append('exampi_fault_daemon')
	command.extend(arguments.program)
	
	# declare EXAMPI_ENV
	env = copy.deepcopy(os.environ)	
	env['EXAMPI_ENV'] = 'local'

	print('srun command:', command)
		
	process = subprocess.Popen(command, env=env)
	return process.wait()

# poor mans Enum
class Scheduler:
	local = 0
	slurm = 1

def detect_scheduler():
	if os.environ.get('SLURM_JOB_ID'):
		return Scheduler.slurm

	else:
		# fallback onto local
		return Scheduler.local 
	
def parse_arguments():
	# command line argument parsing
	parser = argparse.ArgumentParser(description="ExaMPI Process Initiator")

	parser.add_argument('-n', metavar='<numprocs>', type=int, required=True)
	parser.add_argument('-d', default=False, metavar='<dirty>', type=str)
	parser.add_argument('program', metavar='<program>', type=str, nargs=argparse.REMAINDER)

	return parser.parse_args()

def execute_runtime(schedule, arguments):
	if scheduler is Scheduler.slurm:
		run_slurm(arguments)

	elif scheduler is Scheduler.local:
		run_local(arguments)
	
	else:
		raise ValueError

if __name__ == '__main__':
	# prase command line arguments
	arguments = parse_arguments()

	# detect scheduler
	scheduler = detect_scheduler()
	print('Detected scheduler:', scheduler)

	# run scheduler appropriate runtime
	execute_runtime(scheduler, arguments)
